# Django GitHub Actions Testing Setup Guide

## Step 1: Create the GitHub Actions Workflow

Create the directory structure and workflow file in your repository:

```bash
mkdir -p .github/workflows
```

Then create `.github/workflows/ci.yml` with the workflow configuration provided above.

## Step 2: Project Structure

Ensure your project has the following structure:

```
messaging_app/
├── .github/
│   └── workflows/
│       └── ci.yml                    ← CREATE THIS FILE
├── messaging_app/
│   ├── __init__.py
│   ├── settings.py
│   ├── urls.py
│   ├── wsgi.py
│   └── apps/
│       └── your_app/
├── tests/
│   ├── __init__.py
│   ├── test_models.py
│   ├── test_views.py
│   └── test_utils.py
├── requirements.txt
├── manage.py
└── README.md
```

## Step 3: Update Requirements.txt

Make sure your `requirements.txt` includes all necessary dependencies:

```txt
# Django and database
Django>=4.2.0
mysqlclient>=2.2.0

# Testing dependencies
pytest>=7.4.0
pytest-django>=4.5.2
pytest-cov>=4.1.0
pytest-html>=3.2.0
coverage>=7.2.0

# Additional testing tools
factory-boy>=3.3.0
faker>=19.0.0

# Code quality
flake8>=6.0.0
bandit>=1.7.5

# Your app-specific dependencies
# Add your other requirements here
```

## Step 4: Configure Django Settings for Testing

### Option 1: Separate Test Settings File

Create `messaging_app/test_settings.py`:

```python
from .settings import *

# Database configuration for CI/CD
DATABASES = {
    'default': {
        'ENGINE': 'django.db.backends.mysql',
        'NAME': 'test_messaging_app',
        'USER': 'django_user',
        'PASSWORD': 'django_password',
        'HOST': '127.0.0.1',
        'PORT': '3306',
        'OPTIONS': {
            'charset': 'utf8mb4',
        },
        'TEST': {
            'CHARSET': 'utf8mb4',
            'COLLATION': 'utf8mb4_unicode_ci',
        }
    }
}

# Speed up tests
PASSWORD_HASHERS = [
    'django.contrib.auth.hashers.MD5PasswordHasher',
]

# Disable migrations for faster tests
class DisableMigrations:
    def __contains__(self, item):
        return True
    def __getitem__(self, item):
        return None

MIGRATION_MODULES = DisableMigrations()

# Use in-memory cache
CACHES = {
    'default': {
        'BACKEND': 'django.core.cache.backends.locmem.LocMemCache',
    }
}

# Test-specific settings
SECRET_KEY = 'test-secret-key'
DEBUG = True
LOGGING_CONFIG = None
```

### Option 2: Environment-based Settings

Update your main `settings.py` to detect CI environment:

```python
import os

# Detect if running in CI
if os.environ.get('CI'):
    DATABASES = {
        'default': {
            'ENGINE': 'django.db.backends.mysql',
            'NAME': 'test_messaging_app',
            'USER': 'django_user',
            'PASSWORD': 'django_password',
            'HOST': '127.0.0.1',
            'PORT': '3306',
            'OPTIONS': {
                'charset': 'utf8mb4',
            },
            'TEST': {
                'CHARSET': 'utf8mb4',
                'COLLATION': 'utf8mb4_unicode_ci',
            }
        }
    }
```

## Step 5: Create pytest Configuration

Create `pytest.ini` in your project root:

```ini
[tool:pytest]
DJANGO_SETTINGS_MODULE = test_settings
python_files = tests.py test_*.py *_tests.py
addopts = --tb=short --strict-markers --disable-warnings
markers =
    slow: marks tests as slow (deselect with '-m "not slow"')
    integration: marks tests as integration tests
    unit: marks tests as unit tests
```

## Step 6: Sample Test Files

### Sample Model Test (`tests/test_models.py`):

```python
import pytest
from django.test import TestCase
from django.contrib.auth.models import User
from messaging_app.models import Message

class MessageModelTest(TestCase):
    def setUp(self):
        self.user = User.objects.create_user(
            username='testuser',
            email='test@example.com',
            password='testpass'
        )

    def test_message_creation(self):
        message = Message.objects.create(
            sender=self.user,
            content='Test message',
            subject='Test Subject'
        )
        self.assertEqual(message.sender, self.user)
        self.assertEqual(message.content, 'Test message')
        self.assertTrue(message.created_at)

    def test_message_str_representation(self):
        message = Message.objects.create(
            sender=self.user,
            content='Test message',
            subject='Test Subject'
        )
        self.assertEqual(str(message), 'Test Subject')
```

### Sample View Test (`tests/test_views.py`):

```python
import pytest
from django.test import TestCase, Client
from django.urls import reverse
from django.contrib.auth.models import User

class MessageViewTest(TestCase):
    def setUp(self):
        self.client = Client()
        self.user = User.objects.create_user(
            username='testuser',
            email='test@example.com',
            password='testpass'
        )

    def test_message_list_view(self):
        self.client.login(username='testuser', password='testpass')
        response = self.client.get(reverse('message_list'))
        self.assertEqual(response.status_code, 200)

    def test_unauthenticated_access(self):
        response = self.client.get(reverse('message_list'))
        self.assertEqual(response.status_code, 302)  # Redirect to login
```

## Step 7: Configure Code Coverage

Create `.coveragerc` in your project root:

```ini
[run]
source = .
omit = 
    */venv/*
    */env/*
    manage.py
    */settings/*
    */migrations/*
    */tests/*
    */test_*.py
    */__pycache__/*
    */static/*
    */media/*

[report]
exclude_lines =
    pragma: no cover
    def __repr__
    raise AssertionError
    raise NotImplementedError
    if __name__ == .__main__.:
    class .*\bProtocol\):
    @(abc\.)?abstractmethod
```

## Step 8: Local Testing Setup

To test locally before pushing:

```bash
# Install dependencies
pip install -r requirements.txt

# Run tests locally
python manage.py test

# Run with pytest
pytest --cov=. --cov-report=html

# Check code style
flake8 .

# Security check
bandit -r .
```

## Step 9: Commit and Push

```bash
git add .github/workflows/ci.yml
git add requirements.txt
git add pytest.ini
git add .coveragerc
git add tests/
git commit -m "Add GitHub Actions CI/CD pipeline with MySQL testing"
git push origin main
```

## Step 10: Monitor the Workflow

1. Go to your GitHub repository
2. Click on the "Actions" tab
3. You should see your workflow running
4. Click on the workflow run to see detailed logs
5. Each step will show green checkmarks when successful

## Key Features of This Setup:

✅ **Multi-Python Version Testing**: Tests against Python 3.9, 3.10, and 3.11
✅ **MySQL Database Service**: Full MySQL 8.0 database for integration tests
✅ **Comprehensive Testing**: Django tests + pytest + coverage
✅ **Code Quality Checks**: flake8 for style, bandit for security
✅ **Performance Optimizations**: Caching, optimized test settings
✅ **Artifact Upload**: Test reports and coverage data saved
✅ **PR Comments**: Automatic coverage reporting on pull requests
✅ **Branch Protection**: Runs on pushes and pull requests

## Troubleshooting:

1. **MySQL Connection Issues**: The workflow waits for MySQL to be ready
2. **Migration Errors**: Test settings disable migrations for speed
3. **Permission Issues**: All steps run with appropriate permissions
4. **Coverage Not Working**: Check that your tests are in the right directories

This setup provides a robust CI/CD pipeline that will automatically test your Django messaging app on every push and pull request!
